// Code generated by protoc-gen-go. DO NOT EDIT.
// source: strongdoc.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("strongdoc.proto", fileDescriptor_d003557e9d9c9339) }

var fileDescriptor_d003557e9d9c9339 = []byte{
	// 548 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xdd, 0x6a, 0x13, 0x41,
	0x14, 0xc7, 0xdd, 0x94, 0x16, 0x1d, 0xed, 0x87, 0xd3, 0x6a, 0x21, 0x88, 0x8e, 0x01, 0xa9, 0x68,
	0xb3, 0xdb, 0xd6, 0x0b, 0xa1, 0x08, 0x9a, 0xfa, 0x45, 0xb1, 0x62, 0x49, 0x14, 0xc1, 0x1b, 0x99,
	0xcc, 0x9e, 0xce, 0x8e, 0x4d, 0xe6, 0x4c, 0x67, 0x66, 0x1b, 0xe3, 0xa5, 0x08, 0x8a, 0x97, 0xfa,
	0x2c, 0xbe, 0x80, 0xaf, 0xe0, 0x2b, 0xf8, 0x00, 0x3e, 0x82, 0xcc, 0xee, 0x26, 0xf6, 0x23, 0x78,
	0x35, 0x9c, 0xdf, 0xf9, 0xff, 0xff, 0x67, 0x72, 0x32, 0x4b, 0xe6, 0x9d, 0xb7, 0xa8, 0x65, 0x8a,
	0x22, 0x36, 0x16, 0x3d, 0xd2, 0xe9, 0xe2, 0xa8, 0x5f, 0x91, 0x88, 0xb2, 0x07, 0x09, 0x37, 0x2a,
	0xe1, 0x5a, 0xa3, 0xe7, 0x5e, 0xa1, 0x76, 0xa5, 0xa8, 0xbe, 0x5a, 0x1c, 0xa2, 0x29, 0x41, 0x37,
	0xdd, 0x80, 0x4b, 0x09, 0x36, 0x41, 0x53, 0x28, 0x26, 0xa8, 0xe7, 0xb8, 0x10, 0x98, 0x6b, 0x3f,
	0xaa, 0xcf, 0x3b, 0x8f, 0x16, 0xca, 0x62, 0xe3, 0xe7, 0x14, 0x59, 0xe8, 0x14, 0x77, 0x78, 0x84,
	0xa2, 0x03, 0xf6, 0x50, 0x09, 0xa0, 0x9f, 0x22, 0xb2, 0xd4, 0x06, 0xa9, 0x9c, 0x07, 0xfb, 0xc2,
	0x4a, 0xae, 0xd5, 0x87, 0x22, 0x91, 0x5e, 0x2d, 0x5d, 0xf1, 0xa4, 0x66, 0x1b, 0x0e, 0xea, 0xd7,
	0xfe, 0xdb, 0x77, 0xa6, 0x71, 0xfb, 0xe3, 0xaf, 0xdf, 0xdf, 0x6b, 0x37, 0x1a, 0x2c, 0x39, 0x5c,
	0x4f, 0xaa, 0x7b, 0x25, 0x76, 0x82, 0x7a, 0x33, 0xba, 0x45, 0x1f, 0x93, 0x0b, 0xa3, 0xa0, 0x57,
	0x0e, 0x2c, 0xbd, 0x7c, 0x22, 0x3d, 0xc0, 0x30, 0x75, 0x79, 0x22, 0x77, 0xa6, 0x71, 0xe6, 0x66,
	0xb4, 0x16, 0xd1, 0x35, 0x32, 0xbd, 0x83, 0x52, 0x69, 0x3a, 0x5f, 0xe9, 0x8a, 0x2a, 0x18, 0x17,
	0x8e, 0x83, 0xb1, 0x23, 0x21, 0x33, 0x3b, 0x28, 0x31, 0xf7, 0xf4, 0x88, 0x02, 0x73, 0x1f, 0x3c,
	0x17, 0x4f, 0x90, 0x60, 0xa2, 0xf7, 0xc8, 0xb9, 0x4e, 0x58, 0x6a, 0x1b, 0x78, 0x4a, 0x17, 0x2b,
	0xc5, 0x98, 0x04, 0xdb, 0xd2, 0x69, 0x38, 0x1e, 0x77, 0x9f, 0x90, 0x02, 0xbf, 0xb6, 0xca, 0x03,
	0x3d, 0xa6, 0x2c, 0x50, 0xf0, 0x5f, 0x9a, 0x40, 0x47, 0x01, 0x5b, 0x7f, 0x6a, 0xdf, 0x5a, 0x3f,
	0x6a, 0xf4, 0x2e, 0x99, 0x1d, 0xff, 0x95, 0xac, 0xb5, 0xbb, 0xdd, 0xb8, 0x1e, 0x82, 0x03, 0xe8,
	0xf0, 0x9e, 0xaf, 0x2f, 0x2a, 0xbd, 0x87, 0x0f, 0xca, 0x07, 0xe7, 0x78, 0xcf, 0xc7, 0x02, 0xfb,
	0x1b, 0x53, 0xeb, 0xf1, 0xda, 0xc6, 0x02, 0x37, 0xa6, 0xa7, 0x44, 0xb1, 0xf8, 0xe4, 0x9d, 0x43,
	0xbd, 0x79, 0x8a, 0xbc, 0xf9, 0x1a, 0x91, 0xcf, 0x11, 0x21, 0x2d, 0xa3, 0x9e, 0xc1, 0xb0, 0x95,
	0xfb, 0x8c, 0x0e, 0xcf, 0xd6, 0x68, 0xfa, 0x32, 0x03, 0x36, 0x40, 0x9b, 0xb2, 0x95, 0x2d, 0xe0,
	0x16, 0xec, 0x0a, 0xe3, 0x3a, 0x65, 0x9c, 0x39, 0xc3, 0x05, 0x30, 0xe5, 0x98, 0x85, 0x83, 0x5c,
	0x59, 0x48, 0x59, 0x17, 0xf6, 0xd0, 0x02, 0xf3, 0x19, 0x30, 0x8f, 0xfb, 0xa0, 0x63, 0xf2, 0x04,
	0x2d, 0x83, 0xf7, 0xbc, 0x6f, 0x7a, 0xb0, 0x4a, 0x4a, 0x3b, 0xe3, 0xb9, 0xcf, 0x40, 0xfb, 0x6a,
	0xf4, 0xdb, 0x42, 0x59, 0x9f, 0x0d, 0xf3, 0xd0, 0x56, 0x4f, 0x83, 0xd5, 0xec, 0x36, 0x59, 0x7e,
	0x1e, 0xc2, 0x78, 0x17, 0x73, 0xcf, 0x64, 0x7b, 0xf7, 0x61, 0xf3, 0x29, 0xf7, 0x30, 0xe0, 0x43,
	0x1a, 0x67, 0xde, 0x1b, 0xb7, 0x99, 0x24, 0x52, 0xf9, 0x2c, 0xef, 0x86, 0x1f, 0x99, 0x48, 0x6b,
	0x44, 0x13, 0x04, 0xba, 0xa1, 0xf3, 0x50, 0x95, 0xb2, 0xd4, 0x93, 0x86, 0xc0, 0x7e, 0x7c, 0x64,
	0x29, 0xff, 0x3e, 0x48, 0x97, 0xee, 0x97, 0x4b, 0xdf, 0x9a, 0x1b, 0xaf, 0x75, 0x37, 0xd4, 0x5f,
	0xa2, 0xa8, 0x3b, 0x53, 0x74, 0xee, 0xfc, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x09, 0xfb, 0x08, 0x1b,
	0xc1, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StrongDocServiceClient is the client API for StrongDocService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StrongDocServiceClient interface {
	// Registers a new organization
	//
	// The user who created the organization is automatically an administrator
	//
	// Does not require Login
	RegisterOrganization(ctx context.Context, in *RegisterOrganizationReq, opts ...grpc.CallOption) (*RegisterOrganizationResp, error)
	// Register new user
	//
	// Creates new user if it doesn't already exist. If the user already exist, and
	// error is thrown
	//
	// Does not require Login
	RegisterUser(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_RegisterUserClient, error)
	// Obtain an authentication token to be used with other APIs
	//
	// An authentication token will be returned after user has been validated
	// The returned token will be used as a Bearer Token and need to be set in
	// the request header
	Login(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_LoginClient, error)
	// Logout current user
	//
	// Requires Login
	Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*LogoutResp, error)
	//Generic function to download content from some storage
	//
	//Requires Login
	StoreRead(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_StoreReadClient, error)
	//Generic function to upload content to storage
	//
	//Requires Login
	StoreWrite(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_StoreWriteClient, error)
}

type strongDocServiceClient struct {
	cc *grpc.ClientConn
}

func NewStrongDocServiceClient(cc *grpc.ClientConn) StrongDocServiceClient {
	return &strongDocServiceClient{cc}
}

func (c *strongDocServiceClient) RegisterOrganization(ctx context.Context, in *RegisterOrganizationReq, opts ...grpc.CallOption) (*RegisterOrganizationResp, error) {
	out := new(RegisterOrganizationResp)
	err := c.cc.Invoke(ctx, "/proto.StrongDocService/RegisterOrganization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *strongDocServiceClient) RegisterUser(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_RegisterUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StrongDocService_serviceDesc.Streams[0], "/proto.StrongDocService/RegisterUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &strongDocServiceRegisterUserClient{stream}
	return x, nil
}

type StrongDocService_RegisterUserClient interface {
	Send(*RegisterUserReq) error
	Recv() (*RegisterUserResp, error)
	grpc.ClientStream
}

type strongDocServiceRegisterUserClient struct {
	grpc.ClientStream
}

func (x *strongDocServiceRegisterUserClient) Send(m *RegisterUserReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *strongDocServiceRegisterUserClient) Recv() (*RegisterUserResp, error) {
	m := new(RegisterUserResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *strongDocServiceClient) Login(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_LoginClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StrongDocService_serviceDesc.Streams[1], "/proto.StrongDocService/Login", opts...)
	if err != nil {
		return nil, err
	}
	x := &strongDocServiceLoginClient{stream}
	return x, nil
}

type StrongDocService_LoginClient interface {
	Send(*LoginReq) error
	Recv() (*LoginResp, error)
	grpc.ClientStream
}

type strongDocServiceLoginClient struct {
	grpc.ClientStream
}

func (x *strongDocServiceLoginClient) Send(m *LoginReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *strongDocServiceLoginClient) Recv() (*LoginResp, error) {
	m := new(LoginResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *strongDocServiceClient) Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*LogoutResp, error) {
	out := new(LogoutResp)
	err := c.cc.Invoke(ctx, "/proto.StrongDocService/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *strongDocServiceClient) StoreRead(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_StoreReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StrongDocService_serviceDesc.Streams[2], "/proto.StrongDocService/StoreRead", opts...)
	if err != nil {
		return nil, err
	}
	x := &strongDocServiceStoreReadClient{stream}
	return x, nil
}

type StrongDocService_StoreReadClient interface {
	Send(*StoreReadReq) error
	Recv() (*StoreReadResp, error)
	grpc.ClientStream
}

type strongDocServiceStoreReadClient struct {
	grpc.ClientStream
}

func (x *strongDocServiceStoreReadClient) Send(m *StoreReadReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *strongDocServiceStoreReadClient) Recv() (*StoreReadResp, error) {
	m := new(StoreReadResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *strongDocServiceClient) StoreWrite(ctx context.Context, opts ...grpc.CallOption) (StrongDocService_StoreWriteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StrongDocService_serviceDesc.Streams[3], "/proto.StrongDocService/StoreWrite", opts...)
	if err != nil {
		return nil, err
	}
	x := &strongDocServiceStoreWriteClient{stream}
	return x, nil
}

type StrongDocService_StoreWriteClient interface {
	Send(*StoreWriteReq) error
	Recv() (*StoreWriteResp, error)
	grpc.ClientStream
}

type strongDocServiceStoreWriteClient struct {
	grpc.ClientStream
}

func (x *strongDocServiceStoreWriteClient) Send(m *StoreWriteReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *strongDocServiceStoreWriteClient) Recv() (*StoreWriteResp, error) {
	m := new(StoreWriteResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StrongDocServiceServer is the server API for StrongDocService service.
type StrongDocServiceServer interface {
	// Registers a new organization
	//
	// The user who created the organization is automatically an administrator
	//
	// Does not require Login
	RegisterOrganization(context.Context, *RegisterOrganizationReq) (*RegisterOrganizationResp, error)
	// Register new user
	//
	// Creates new user if it doesn't already exist. If the user already exist, and
	// error is thrown
	//
	// Does not require Login
	RegisterUser(StrongDocService_RegisterUserServer) error
	// Obtain an authentication token to be used with other APIs
	//
	// An authentication token will be returned after user has been validated
	// The returned token will be used as a Bearer Token and need to be set in
	// the request header
	Login(StrongDocService_LoginServer) error
	// Logout current user
	//
	// Requires Login
	Logout(context.Context, *LogoutReq) (*LogoutResp, error)
	//Generic function to download content from some storage
	//
	//Requires Login
	StoreRead(StrongDocService_StoreReadServer) error
	//Generic function to upload content to storage
	//
	//Requires Login
	StoreWrite(StrongDocService_StoreWriteServer) error
}

// UnimplementedStrongDocServiceServer can be embedded to have forward compatible implementations.
type UnimplementedStrongDocServiceServer struct {
}

func (*UnimplementedStrongDocServiceServer) RegisterOrganization(ctx context.Context, req *RegisterOrganizationReq) (*RegisterOrganizationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterOrganization not implemented")
}
func (*UnimplementedStrongDocServiceServer) RegisterUser(srv StrongDocService_RegisterUserServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}
func (*UnimplementedStrongDocServiceServer) Login(srv StrongDocService_LoginServer) error {
	return status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (*UnimplementedStrongDocServiceServer) Logout(ctx context.Context, req *LogoutReq) (*LogoutResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (*UnimplementedStrongDocServiceServer) StoreRead(srv StrongDocService_StoreReadServer) error {
	return status.Errorf(codes.Unimplemented, "method StoreRead not implemented")
}
func (*UnimplementedStrongDocServiceServer) StoreWrite(srv StrongDocService_StoreWriteServer) error {
	return status.Errorf(codes.Unimplemented, "method StoreWrite not implemented")
}

func RegisterStrongDocServiceServer(s *grpc.Server, srv StrongDocServiceServer) {
	s.RegisterService(&_StrongDocService_serviceDesc, srv)
}

func _StrongDocService_RegisterOrganization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterOrganizationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StrongDocServiceServer).RegisterOrganization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.StrongDocService/RegisterOrganization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StrongDocServiceServer).RegisterOrganization(ctx, req.(*RegisterOrganizationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _StrongDocService_RegisterUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StrongDocServiceServer).RegisterUser(&strongDocServiceRegisterUserServer{stream})
}

type StrongDocService_RegisterUserServer interface {
	Send(*RegisterUserResp) error
	Recv() (*RegisterUserReq, error)
	grpc.ServerStream
}

type strongDocServiceRegisterUserServer struct {
	grpc.ServerStream
}

func (x *strongDocServiceRegisterUserServer) Send(m *RegisterUserResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *strongDocServiceRegisterUserServer) Recv() (*RegisterUserReq, error) {
	m := new(RegisterUserReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StrongDocService_Login_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StrongDocServiceServer).Login(&strongDocServiceLoginServer{stream})
}

type StrongDocService_LoginServer interface {
	Send(*LoginResp) error
	Recv() (*LoginReq, error)
	grpc.ServerStream
}

type strongDocServiceLoginServer struct {
	grpc.ServerStream
}

func (x *strongDocServiceLoginServer) Send(m *LoginResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *strongDocServiceLoginServer) Recv() (*LoginReq, error) {
	m := new(LoginReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StrongDocService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StrongDocServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.StrongDocService/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StrongDocServiceServer).Logout(ctx, req.(*LogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _StrongDocService_StoreRead_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StrongDocServiceServer).StoreRead(&strongDocServiceStoreReadServer{stream})
}

type StrongDocService_StoreReadServer interface {
	Send(*StoreReadResp) error
	Recv() (*StoreReadReq, error)
	grpc.ServerStream
}

type strongDocServiceStoreReadServer struct {
	grpc.ServerStream
}

func (x *strongDocServiceStoreReadServer) Send(m *StoreReadResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *strongDocServiceStoreReadServer) Recv() (*StoreReadReq, error) {
	m := new(StoreReadReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StrongDocService_StoreWrite_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StrongDocServiceServer).StoreWrite(&strongDocServiceStoreWriteServer{stream})
}

type StrongDocService_StoreWriteServer interface {
	Send(*StoreWriteResp) error
	Recv() (*StoreWriteReq, error)
	grpc.ServerStream
}

type strongDocServiceStoreWriteServer struct {
	grpc.ServerStream
}

func (x *strongDocServiceStoreWriteServer) Send(m *StoreWriteResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *strongDocServiceStoreWriteServer) Recv() (*StoreWriteReq, error) {
	m := new(StoreWriteReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _StrongDocService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.StrongDocService",
	HandlerType: (*StrongDocServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterOrganization",
			Handler:    _StrongDocService_RegisterOrganization_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _StrongDocService_Logout_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterUser",
			Handler:       _StrongDocService_RegisterUser_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Login",
			Handler:       _StrongDocService_Login_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StoreRead",
			Handler:       _StrongDocService_StoreRead_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StoreWrite",
			Handler:       _StrongDocService_StoreWrite_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "strongdoc.proto",
}
